/**
 * AI Action Auto-Generator for App Layer
 *
 * Generate AI actions from workflow definitions
 */

import type {
  AiAction,
  AiActionDefinition,
  AiActionHandler,
  AiRegistry,
  EffectiveAiDataPolicy,
  JsonSchema,
} from "@takos/platform/server";
import type {
  WorkflowDefinition,
  WorkflowRegistry,
  WorkflowEngine,
  WorkflowStep,
  WorkflowExecutionContext,
} from "./types.js";

// ========================================
// Types
// ========================================

/**
 * Metadata for auto-generated actions
 */
export interface GeneratedActionMetadata {
  /** Source workflow ID */
  sourceWorkflowId: string;
  /** Workflow version */
  workflowVersion: string;
  /** Generation timestamp */
  generatedAt: string;
  /** Auto-generated flag */
  isAutoGenerated: true;
}

/**
 * Action generation options
 */
export interface ActionGeneratorOptions {
  /** Action ID prefix (default: "workflow.") */
  actionIdPrefix?: string;
  /** Label prefix (default: "[Workflow] ") */
  labelPrefix?: string;
  /** Data policy override */
  dataPolicyOverride?: Partial<EffectiveAiDataPolicy>;
  /** Custom validation function */
  validate?: (definition: WorkflowDefinition) => boolean;
}

/**
 * Action generation result
 */
export interface ActionGeneratorResult {
  success: boolean;
  action?: AiAction;
  actionId?: string;
  error?: string;
  metadata?: GeneratedActionMetadata;
}

// ========================================
// Schema Inference
// ========================================

/**
 * Merge JSON schemas
 */
function mergeSchemas(base: JsonSchema, override: JsonSchema): JsonSchema {
  if (base.type !== "object" || override.type !== "object") {
    return override;
  }

  const baseProps = base.properties || {};
  const overrideProps = override.properties || {};
  const baseRequired = Array.isArray(base.required) ? base.required : [];
  const overrideRequired = Array.isArray(override.required) ? override.required : [];

  return {
    type: "object",
    properties: { ...baseProps, ...overrideProps },
    required: Array.from(new Set([...baseRequired, ...overrideRequired])),
  };
}

/**
 * Infer input schema from workflow
 */
export function inferInputSchema(workflow: WorkflowDefinition): JsonSchema {
  // Use explicit input schema if available
  if (workflow.inputSchema && Object.keys(workflow.inputSchema).length > 0) {
    return workflow.inputSchema as JsonSchema;
  }

  // Infer from step input mappings
  const inferredProperties: Record<string, JsonSchema> = {};
  const requiredFields: string[] = [];

  for (const step of workflow.steps) {
    if (!step.inputMapping) continue;

    for (const [key, mapping] of Object.entries(step.inputMapping)) {
      if (typeof mapping === "object" && mapping.type === "ref") {
        if (mapping.stepId === "input") {
          // Reference from workflow input
          const path = mapping.path;
          const fieldName = path.split(".")[0];

          if (!inferredProperties[fieldName]) {
            inferredProperties[fieldName] = {
              type: "string",
              description: `Input field referenced by step "${step.id}"`,
            };
            // Fields referenced in input mapping are considered required
            requiredFields.push(fieldName);
          }
        }
      }
    }
  }

  return {
    type: "object",
    properties: inferredProperties,
    required: Array.from(new Set(requiredFields)),
  };
}

/**
 * Infer output schema from workflow
 */
export function inferOutputSchema(workflow: WorkflowDefinition): JsonSchema {
  // Use explicit output schema if available
  if (workflow.outputSchema && Object.keys(workflow.outputSchema).length > 0) {
    return workflow.outputSchema as JsonSchema;
  }

  // Infer from last step
  const lastStep = workflow.steps[workflow.steps.length - 1];
  if (!lastStep) {
    return {
      type: "object",
      properties: {
        result: { type: "string", description: "Workflow execution result" },
      },
    };
  }

  return inferStepOutputSchema(lastStep);
}

/**
 * Infer step output schema
 */
function inferStepOutputSchema(step: WorkflowStep): JsonSchema {
  switch (step.type) {
    case "ai_action":
      return {
        type: "object",
        properties: {
          result: { description: `Output from AI action step "${step.id}"` },
        },
      };

    case "transform":
      return {
        type: "object",
        properties: {
          transformed: { description: `Transformed data from step "${step.id}"` },
        },
      };

    case "condition":
      return {
        type: "object",
        properties: {
          selectedBranch: { type: "string", description: "Selected branch" },
        },
      };

    case "loop":
      return {
        type: "object",
        properties: {
          iterations: { type: "number" },
          results: { type: "array" },
        },
      };

    case "parallel":
      return {
        type: "object",
        properties: {
          branches: { type: "array", description: "Results from parallel branches" },
        },
      };

    case "human_approval":
      return {
        type: "object",
        properties: {
          approved: { type: "boolean" },
          choice: { type: "string" },
        },
      };

    case "tool_call":
      return {
        type: "object",
        properties: {
          result: { description: `Result from tool call "${step.id}"` },
        },
      };

    default:
      return {
        type: "object",
        properties: {},
      };
  }
}

// ========================================
// Data Policy Inference
// ========================================

/**
 * Infer data policy from workflow
 */
export function inferDataPolicy(workflow: WorkflowDefinition): Partial<EffectiveAiDataPolicy> {
  return { ...workflow.dataPolicy };
}

/**
 * Merge multiple data policies (OR logic)
 */
export function mergeDataPolicies(
  ...policies: Partial<EffectiveAiDataPolicy>[]
): Partial<EffectiveAiDataPolicy> {
  const merged: Partial<EffectiveAiDataPolicy> = {
    sendPublicPosts: false,
    sendCommunityPosts: false,
    sendDm: false,
    sendProfile: false,
  };

  for (const policy of policies) {
    if (policy.sendPublicPosts) merged.sendPublicPosts = true;
    if (policy.sendCommunityPosts) merged.sendCommunityPosts = true;
    if (policy.sendDm) merged.sendDm = true;
    if (policy.sendProfile) merged.sendProfile = true;
    if (policy.notes) {
      merged.notes = merged.notes
        ? `${merged.notes}; ${policy.notes}`
        : policy.notes;
    }
  }

  return merged;
}

// ========================================
// Action Generator
// ========================================

/**
 * Workflow action generator
 */
export class WorkflowActionGenerator {
  private readonly workflowRegistry: WorkflowRegistry;
  private readonly workflowEngine: WorkflowEngine;
  private readonly options: Required<ActionGeneratorOptions>;

  constructor(
    workflowRegistry: WorkflowRegistry,
    workflowEngine: WorkflowEngine,
    options: ActionGeneratorOptions = {},
  ) {
    this.workflowRegistry = workflowRegistry;
    this.workflowEngine = workflowEngine;
    this.options = {
      actionIdPrefix: options.actionIdPrefix ?? "workflow.",
      labelPrefix: options.labelPrefix ?? "[Workflow] ",
      dataPolicyOverride: options.dataPolicyOverride ?? {},
      validate: options.validate ?? (() => true),
    };
  }

  /**
   * Generate action ID from workflow definition
   */
  generateActionId(workflow: WorkflowDefinition): string {
    if (workflow.id.startsWith(this.options.actionIdPrefix)) {
      return workflow.id;
    }
    return `${this.options.actionIdPrefix}${workflow.id.replace(/^workflow\./, "")}`;
  }

  /**
   * Generate action from workflow definition
   */
  generate(workflowId: string): ActionGeneratorResult {
    const workflow = this.workflowRegistry.getDefinition(workflowId);
    if (!workflow) {
      return {
        success: false,
        error: `Workflow not found: ${workflowId}`,
      };
    }

    return this.generateFromDefinition(workflow);
  }

  /**
   * Generate action directly from workflow definition object
   */
  generateFromDefinition(workflow: WorkflowDefinition): ActionGeneratorResult {
    // Validation
    if (!this.options.validate(workflow)) {
      return {
        success: false,
        error: `Workflow validation failed: ${workflow.id}`,
      };
    }

    const actionId = this.generateActionId(workflow);
    const now = new Date().toISOString();

    // Metadata
    const metadata: GeneratedActionMetadata = {
      sourceWorkflowId: workflow.id,
      workflowVersion: workflow.version,
      generatedAt: now,
      isAutoGenerated: true,
    };

    // Schema inference
    const inputSchema = inferInputSchema(workflow);
    const outputSchema = inferOutputSchema(workflow);

    // Merge data policies
    const dataPolicy = mergeDataPolicies(
      inferDataPolicy(workflow),
      this.options.dataPolicyOverride,
    );

    // Action definition
    const definition: AiActionDefinition = {
      id: actionId,
      label: `${this.options.labelPrefix}${workflow.name}`,
      description: `${workflow.description} (Auto-generated from workflow ${workflow.id})`,
      inputSchema,
      outputSchema,
      providerCapabilities: ["chat"], // Workflows typically use chat capability
      dataPolicy,
    };

    // Create handler
    const handler = this.createHandler(workflow);

    const action: AiAction = {
      definition,
      handler,
    };

    return {
      success: true,
      action,
      actionId,
      metadata,
    };
  }

  /**
   * Create workflow execution handler
   */
  private createHandler(workflow: WorkflowDefinition): AiActionHandler {
    const engine = this.workflowEngine;
    const workflowId = workflow.id;

    return async (ctx, input) => {
      const workflowInput = (typeof input === "object" && input !== null)
        ? input as Record<string, unknown>
        : { value: input };

      // Build workflow execution context
      const providers = (ctx as Record<string, unknown>).providers;
      const execContext: Omit<WorkflowExecutionContext, "instance"> = {
        nodeConfig: ctx.nodeConfig as WorkflowExecutionContext["nodeConfig"],
        provider: providers as WorkflowExecutionContext["provider"],
        dataPolicy: {
          sendPublicPosts: workflow.dataPolicy?.sendPublicPosts ?? false,
          sendCommunityPosts: workflow.dataPolicy?.sendCommunityPosts ?? false,
          sendDm: workflow.dataPolicy?.sendDm ?? false,
          sendProfile: workflow.dataPolicy?.sendProfile ?? false,
        },
        auth: {
          userId: null,
          sessionId: null,
          isAuthenticated: false,
        },
        env: {},
        log: (level, message, data) => {
          console.log(`[workflow:${workflowId}] [${level}] ${message}`, data);
        },
      };

      // Execute workflow
      const instance = await engine.start(workflowId, workflowInput, execContext);

      // Return result if completed synchronously
      if (instance.status === "completed") {
        return instance.output ?? { success: true };
      }

      if (instance.status === "failed") {
        throw new Error(instance.error?.message ?? "Workflow execution failed");
      }

      // In progress or paused
      return {
        instanceId: instance.id,
        status: instance.status,
        currentStep: instance.currentStepId,
      };
    };
  }

  /**
   * Generate actions from all registered workflows
   */
  generateAll(): ActionGeneratorResult[] {
    const workflows = this.workflowRegistry.listDefinitions();
    return workflows.map((workflow) => this.generateFromDefinition(workflow));
  }
}

// ========================================
// Registry Integration
// ========================================

/**
 * Register generated action to registry
 */
export function registerGeneratedAction(
  registry: AiRegistry,
  result: ActionGeneratorResult,
): boolean {
  if (!result.success || !result.action) {
    return false;
  }

  try {
    // Don't overwrite existing actions
    const existing = registry.getAction(result.action.definition.id);
    if (existing) {
      console.warn(
        `[action-generator] Action already exists, skipping: ${result.action.definition.id}`,
      );
      return false;
    }

    registry.register(result.action);
    return true;
  } catch (error) {
    console.error(
      `[action-generator] Failed to register action: ${result.action.definition.id}`,
      error,
    );
    return false;
  }
}

/**
 * Generate and register actions from all registered workflows
 */
export function registerWorkflowsAsActions(
  workflowRegistry: WorkflowRegistry,
  workflowEngine: WorkflowEngine,
  aiRegistry: AiRegistry,
  options?: ActionGeneratorOptions,
): { registered: string[]; failed: string[] } {
  const generator = new WorkflowActionGenerator(workflowRegistry, workflowEngine, options);
  const results = generator.generateAll();

  const registered: string[] = [];
  const failed: string[] = [];

  for (const result of results) {
    if (result.success && result.action) {
      if (registerGeneratedAction(aiRegistry, result)) {
        registered.push(result.actionId!);
      } else {
        failed.push(result.actionId ?? "unknown");
      }
    } else {
      failed.push(result.error ?? "unknown workflow");
    }
  }

  console.log(
    `[action-generator] Registered ${registered.length} actions, ${failed.length} failed`,
  );

  return { registered, failed };
}

// ========================================
// Factory Functions
// ========================================

/**
 * Create action generator
 */
export function createActionGenerator(
  workflowRegistry: WorkflowRegistry,
  workflowEngine: WorkflowEngine,
  options?: ActionGeneratorOptions,
): WorkflowActionGenerator {
  return new WorkflowActionGenerator(workflowRegistry, workflowEngine, options);
}
