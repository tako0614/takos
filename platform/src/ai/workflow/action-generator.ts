/**
 * AI Action Auto-Generator
 *
 * ワークフロー定義から AI アクションを自動生成するモジュール
 * PLAN.md 6.3/6.8 に基づくアクション自動生成機能
 */

import type { AiAction, AiActionDefinition, AiActionHandler, AiRegistry } from "../action-registry";
import type { EffectiveAiDataPolicy } from "../provider-registry";
import type { JsonSchema } from "../../config/takos-config";
import type {
  WorkflowDefinition,
  WorkflowRegistry,
  WorkflowEngine,
  WorkflowStep,
  WorkflowExecutionContext,
} from "./types";

// ========================================
// Types
// ========================================

/**
 * 自動生成されたアクションのメタデータ
 */
export interface GeneratedActionMetadata {
  /** 元となったワークフローID */
  sourceWorkflowId: string;
  /** ワークフローのバージョン */
  workflowVersion: string;
  /** 生成日時 */
  generatedAt: string;
  /** 自動生成フラグ */
  isAutoGenerated: true;
}

/**
 * アクション生成オプション
 */
export interface ActionGeneratorOptions {
  /** アクションIDのプレフィックス（デフォルト: "workflow."） */
  actionIdPrefix?: string;
  /** ラベルの接頭辞（デフォルト: "[Workflow] "） */
  labelPrefix?: string;
  /** データポリシーのオーバーライド */
  dataPolicyOverride?: Partial<EffectiveAiDataPolicy>;
  /** 生成時のカスタムバリデーション */
  validate?: (definition: WorkflowDefinition) => boolean;
}

/**
 * アクション生成結果
 */
export interface ActionGeneratorResult {
  success: boolean;
  action?: AiAction;
  actionId?: string;
  error?: string;
  metadata?: GeneratedActionMetadata;
}

// ========================================
// Schema Inference
// ========================================

/**
 * JSON Schema を深くマージする
 */
function mergeSchemas(base: JsonSchema, override: JsonSchema): JsonSchema {
  if (base.type !== "object" || override.type !== "object") {
    return override;
  }

  const baseProps = base.properties || {};
  const overrideProps = override.properties || {};
  const baseRequired = Array.isArray(base.required) ? base.required : [];
  const overrideRequired = Array.isArray(override.required) ? override.required : [];

  return {
    type: "object",
    properties: { ...baseProps, ...overrideProps },
    required: Array.from(new Set([...baseRequired, ...overrideRequired])),
  };
}

/**
 * ワークフローの入力スキーマを推論する
 */
export function inferInputSchema(workflow: WorkflowDefinition): JsonSchema {
  // ワークフローに明示的な入力スキーマがあればそれを使用
  if (workflow.inputSchema && Object.keys(workflow.inputSchema).length > 0) {
    return workflow.inputSchema as JsonSchema;
  }

  // ステップの入力マッピングからスキーマを推論
  const inferredProperties: Record<string, JsonSchema> = {};
  const requiredFields: string[] = [];

  for (const step of workflow.steps) {
    if (!step.inputMapping) continue;

    for (const [key, mapping] of Object.entries(step.inputMapping)) {
      if (typeof mapping === "object" && mapping.type === "ref") {
        if (mapping.stepId === "input") {
          // ワークフロー入力からの参照
          const path = mapping.path;
          const fieldName = path.split(".")[0];

          if (!inferredProperties[fieldName]) {
            inferredProperties[fieldName] = {
              type: "string",
              description: `Input field referenced by step "${step.id}"`,
            };
            // 入力マッピングで参照されているフィールドは必須とみなす
            requiredFields.push(fieldName);
          }
        }
      }
    }
  }

  return {
    type: "object",
    properties: inferredProperties,
    required: Array.from(new Set(requiredFields)),
  };
}

/**
 * ワークフローの出力スキーマを推論する
 */
export function inferOutputSchema(workflow: WorkflowDefinition): JsonSchema {
  // ワークフローに明示的な出力スキーマがあればそれを使用
  if (workflow.outputSchema && Object.keys(workflow.outputSchema).length > 0) {
    return workflow.outputSchema as JsonSchema;
  }

  // 最後のステップから出力スキーマを推論
  const lastStep = workflow.steps[workflow.steps.length - 1];
  if (!lastStep) {
    return {
      type: "object",
      properties: {
        result: { type: "string", description: "Workflow execution result" },
      },
    };
  }

  // ステップタイプに応じた推論
  return inferStepOutputSchema(lastStep);
}

/**
 * ステップの出力スキーマを推論する
 */
function inferStepOutputSchema(step: WorkflowStep): JsonSchema {
  switch (step.type) {
    case "ai_action":
      return {
        type: "object",
        properties: {
          result: { description: `Output from AI action step "${step.id}"` },
        },
      };

    case "transform":
      return {
        type: "object",
        properties: {
          transformed: { description: `Transformed data from step "${step.id}"` },
        },
      };

    case "condition":
      return {
        type: "object",
        properties: {
          selectedBranch: { type: "string", description: "Selected branch" },
        },
      };

    case "loop":
      return {
        type: "object",
        properties: {
          iterations: { type: "number" },
          results: { type: "array" },
        },
      };

    case "parallel":
      return {
        type: "object",
        properties: {
          branches: { type: "array", description: "Results from parallel branches" },
        },
      };

    case "human_approval":
      return {
        type: "object",
        properties: {
          approved: { type: "boolean" },
          choice: { type: "string" },
        },
      };

    case "tool_call":
      return {
        type: "object",
        properties: {
          result: { description: `Result from tool call "${step.id}"` },
        },
      };

    default:
      return {
        type: "object",
        properties: {},
      };
  }
}

// ========================================
// Data Policy Inference
// ========================================

/**
 * ワークフローからデータポリシーをマージする
 */
export function inferDataPolicy(workflow: WorkflowDefinition): Partial<EffectiveAiDataPolicy> {
  // ワークフロー全体のポリシーをベースにする
  const basePolicy: Partial<EffectiveAiDataPolicy> = { ...workflow.dataPolicy };

  // 各ステップの AI アクションからデータポリシーを収集
  // Note: 実際の AI アクション定義を参照する必要がある場合は、
  // AiRegistry を渡してアクション定義を取得する
  for (const step of workflow.steps) {
    if (step.type === "ai_action") {
      const config = step.config as { type: "ai_action"; actionId: string };
      // AI アクションのデータポリシーはレジストリから取得する必要があるが、
      // ここでは保守的に推論する
      // 実際の実装では AiRegistry.getAction(config.actionId) を呼び出す
    }
  }

  return basePolicy;
}

/**
 * 複数のデータポリシーをマージする（OR 論理）
 */
export function mergeDataPolicies(
  ...policies: Partial<EffectiveAiDataPolicy>[]
): Partial<EffectiveAiDataPolicy> {
  const merged: Partial<EffectiveAiDataPolicy> = {
    sendPublicPosts: false,
    sendCommunityPosts: false,
    sendDm: false,
    sendProfile: false,
  };

  for (const policy of policies) {
    if (policy.sendPublicPosts) merged.sendPublicPosts = true;
    if (policy.sendCommunityPosts) merged.sendCommunityPosts = true;
    if (policy.sendDm) merged.sendDm = true;
    if (policy.sendProfile) merged.sendProfile = true;
    if (policy.notes) {
      merged.notes = merged.notes
        ? `${merged.notes}; ${policy.notes}`
        : policy.notes;
    }
  }

  return merged;
}

// ========================================
// Action Generator
// ========================================

/**
 * ワークフローから AI アクションを生成するジェネレーター
 */
export class WorkflowActionGenerator {
  private readonly workflowRegistry: WorkflowRegistry;
  private readonly workflowEngine: WorkflowEngine;
  private readonly options: Required<ActionGeneratorOptions>;

  constructor(
    workflowRegistry: WorkflowRegistry,
    workflowEngine: WorkflowEngine,
    options: ActionGeneratorOptions = {},
  ) {
    this.workflowRegistry = workflowRegistry;
    this.workflowEngine = workflowEngine;
    this.options = {
      actionIdPrefix: options.actionIdPrefix ?? "workflow.",
      labelPrefix: options.labelPrefix ?? "[Workflow] ",
      dataPolicyOverride: options.dataPolicyOverride ?? {},
      validate: options.validate ?? (() => true),
    };
  }

  /**
   * ワークフロー定義からアクションIDを生成
   */
  generateActionId(workflow: WorkflowDefinition): string {
    // workflow.content_moderation -> workflow.content_moderation (そのまま使用)
    // または prefix を付与
    if (workflow.id.startsWith(this.options.actionIdPrefix)) {
      return workflow.id;
    }
    return `${this.options.actionIdPrefix}${workflow.id.replace(/^workflow\./, "")}`;
  }

  /**
   * ワークフロー定義からアクションを生成
   */
  generate(workflowId: string): ActionGeneratorResult {
    const workflow = this.workflowRegistry.getDefinition(workflowId);
    if (!workflow) {
      return {
        success: false,
        error: `Workflow not found: ${workflowId}`,
      };
    }

    return this.generateFromDefinition(workflow);
  }

  /**
   * ワークフロー定義オブジェクトからアクションを直接生成
   */
  generateFromDefinition(workflow: WorkflowDefinition): ActionGeneratorResult {
    // バリデーション
    if (!this.options.validate(workflow)) {
      return {
        success: false,
        error: `Workflow validation failed: ${workflow.id}`,
      };
    }

    const actionId = this.generateActionId(workflow);
    const now = new Date().toISOString();

    // メタデータ
    const metadata: GeneratedActionMetadata = {
      sourceWorkflowId: workflow.id,
      workflowVersion: workflow.version,
      generatedAt: now,
      isAutoGenerated: true,
    };

    // スキーマ推論
    const inputSchema = inferInputSchema(workflow);
    const outputSchema = inferOutputSchema(workflow);

    // データポリシーのマージ
    const dataPolicy = mergeDataPolicies(
      inferDataPolicy(workflow),
      this.options.dataPolicyOverride,
    );

    // アクション定義
    const definition: AiActionDefinition = {
      id: actionId,
      label: `${this.options.labelPrefix}${workflow.name}`,
      description: `${workflow.description} (Auto-generated from workflow ${workflow.id})`,
      inputSchema,
      outputSchema,
      providerCapabilities: ["chat"], // ワークフローは通常 chat 機能を使用
      dataPolicy,
    };

    // ハンドラー作成
    const handler = this.createHandler(workflow);

    const action: AiAction = {
      definition,
      handler,
    };

    return {
      success: true,
      action,
      actionId,
      metadata,
    };
  }

  /**
   * ワークフロー実行ハンドラーを作成
   */
  private createHandler(workflow: WorkflowDefinition): AiActionHandler {
    const engine = this.workflowEngine;
    const workflowId = workflow.id;

    return async (ctx, input) => {
      const workflowInput = (typeof input === "object" && input !== null)
        ? input as Record<string, unknown>
        : { value: input };

      // ワークフロー実行コンテキストを構築
      // Note: provider は AiActionContext から取得。存在しない場合はダミーを使用
      const providers = (ctx as Record<string, unknown>).providers;
      const execContext: Omit<WorkflowExecutionContext, "instance"> = {
        nodeConfig: ctx.nodeConfig as WorkflowExecutionContext["nodeConfig"],
        provider: providers as WorkflowExecutionContext["provider"],
        dataPolicy: {
          sendPublicPosts: workflow.dataPolicy?.sendPublicPosts ?? false,
          sendCommunityPosts: workflow.dataPolicy?.sendCommunityPosts ?? false,
          sendDm: workflow.dataPolicy?.sendDm ?? false,
          sendProfile: workflow.dataPolicy?.sendProfile ?? false,
        },
        auth: {
          userId: null,
          sessionId: null,
          isAuthenticated: false,
        },
        env: {},
        log: (level, message, data) => {
          console.log(`[workflow:${workflowId}] [${level}] ${message}`, data);
        },
      };

      // ワークフローを実行
      const instance = await engine.start(workflowId, workflowInput, execContext);

      // ワークフローが同期的に完了した場合は結果を返す
      // 非同期ワークフローの場合はインスタンスIDを返す
      if (instance.status === "completed") {
        return instance.output ?? { success: true };
      }

      if (instance.status === "failed") {
        throw new Error(instance.error?.message ?? "Workflow execution failed");
      }

      // 進行中または一時停止中の場合
      return {
        instanceId: instance.id,
        status: instance.status,
        currentStep: instance.currentStepId,
      };
    };
  }

  /**
   * すべての登録済みワークフローからアクションを一括生成
   */
  generateAll(): ActionGeneratorResult[] {
    const workflows = this.workflowRegistry.listDefinitions();
    return workflows.map((workflow) => this.generateFromDefinition(workflow));
  }
}

// ========================================
// Registry Integration
// ========================================

/**
 * 生成されたアクションをレジストリに登録
 */
export function registerGeneratedAction(
  registry: AiRegistry,
  result: ActionGeneratorResult,
): boolean {
  if (!result.success || !result.action) {
    return false;
  }

  try {
    // 既存のアクションがあれば上書きしない
    const existing = registry.getAction(result.action.definition.id);
    if (existing) {
      console.warn(
        `[action-generator] Action already exists, skipping: ${result.action.definition.id}`,
      );
      return false;
    }

    registry.register(result.action);
    return true;
  } catch (error) {
    console.error(
      `[action-generator] Failed to register action: ${result.action.definition.id}`,
      error,
    );
    return false;
  }
}

/**
 * すべての登録済みワークフローからアクションを生成して登録
 */
export function registerWorkflowsAsActions(
  workflowRegistry: WorkflowRegistry,
  workflowEngine: WorkflowEngine,
  aiRegistry: AiRegistry,
  options?: ActionGeneratorOptions,
): { registered: string[]; failed: string[] } {
  const generator = new WorkflowActionGenerator(workflowRegistry, workflowEngine, options);
  const results = generator.generateAll();

  const registered: string[] = [];
  const failed: string[] = [];

  for (const result of results) {
    if (result.success && result.action) {
      if (registerGeneratedAction(aiRegistry, result)) {
        registered.push(result.actionId!);
      } else {
        failed.push(result.actionId ?? "unknown");
      }
    } else {
      failed.push(result.error ?? "unknown workflow");
    }
  }

  console.log(
    `[action-generator] Registered ${registered.length} actions, ${failed.length} failed`,
  );

  return { registered, failed };
}

// ========================================
// Factory Functions
// ========================================

/**
 * アクションジェネレーターを作成
 */
export function createActionGenerator(
  workflowRegistry: WorkflowRegistry,
  workflowEngine: WorkflowEngine,
  options?: ActionGeneratorOptions,
): WorkflowActionGenerator {
  return new WorkflowActionGenerator(workflowRegistry, workflowEngine, options);
}
